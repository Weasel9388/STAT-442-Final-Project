total_release = sum(total_releases, na.rm = TRUE)
) %>%
pivot_longer(everything(), names_to = "category", values_to = "amount") %>%
mutate(proportion = amount / sum(amount),
category = case_when(
category == "total_treated" ~ "Treated",
category == "total_recycled" ~ "Recycled",
category == "total_energy_recovery" ~ "Energy Recovery",
category == "total_release" ~ "Released",
TRUE ~ category
))
# Plot for Proportions
ggplot(proportions, aes(x = reorder(category, -proportion), y = proportion, fill = category)) +
geom_bar(stat = "identity") +
geom_text(aes(label = scales::percent(proportion, accuracy = 0.1)),
position = position_stack(vjust = 0.5)) +
labs(title = "Proportion of Toxins Treated, Recycled, Recovered, and Released",
x = "Category",
y = "Proportion") +
theme_minimal() +
theme(legend.position = "none") +
scale_y_continuous(labels = scales::percent) +
scale_fill_brewer(palette = "Set2")
# Calculate on-site and off-site releases
onsite_offsite_summary <- toxins_named %>%
summarise(
on_site_release = sum(on_site_release_total, na.rm = TRUE),
off_site_release = sum(off_site_release_total, na.rm = TRUE)
) %>%
pivot_longer(everything(), names_to = "release_type", values_to = "amount") %>%
mutate(release_type = case_when(
release_type == "on_site_release" ~ "On-Site Release",
release_type == "off_site_release" ~ "Off-Site Release",
TRUE ~ release_type
))
# Calculate percentages
total_release <- sum(onsite_offsite_summary$amount)
onsite_offsite_summary <- onsite_offsite_summary %>%
mutate(percentage = amount / total_release * 100)
# Plot for On-Site vs Off-Site Releases
ggplot(onsite_offsite_summary, aes(x = release_type, y = amount, fill = release_type)) +
geom_bar(stat = "identity", width = 0.6) +
geom_text(aes(label = paste0(comma(amount), "\n(", round(percentage, 1), "%)")),
position = position_stack(vjust = 0.5),
size = 4) +
labs(title = "Comparison of On-Site vs Off-Site Releases",
x = NULL,  # Remove x-axis label as it's redundant
y = "Total Amount",
fill = "Release Type") +
theme_minimal() +
theme(legend.position = "none",  # Remove legend as it's redundant
axis.text.x = element_text(size = 12, face = "bold"),
plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
scale_y_continuous(labels = comma) +
scale_fill_brewer(palette = "Set2")
library(dplyr)
library(readr)
library(DataExplorer)
library(cluster)
library(factoextra)
library(FactoMineR)
library(janitor)
library(ggplot2)
library(tidyr)
library(reshape2)
library(stringr)
library(scales)
knitr::opts_chunk$set(echo = TRUE)
ggplotly(p1)
library(dplyr)
library(readr)
library(DataExplorer)
library(cluster)
library(factoextra)
library(FactoMineR)
library(janitor)
library(ggplot2)
library(tidyr)
library(reshape2)
library(stringr)
library(scales)
library(ggplotify)
knitr::opts_chunk$set(echo = TRUE)
# Load required libraries
library(dplyr)
library(janitor)
library(ggplot2)
library(tidyr)
library(reshape2)
library(stringr)
library(scales)
# Clean all column names and address multiple patterns like 'x#_', '5_5_1_', and '6_2_m79'
toxins_named <- toxins_2023 %>%
clean_names() %>%
rename_with(~ gsub("^x\\d+_", "", .), everything()) %>%  # Remove 'x#_' prefixes
rename_with(~ gsub("^\\d+(_\\d+)*_", "", .), everything())  # Remove leading numeric patterns like '5_5_1_' or '6_2_'
toxins_named <- toxins_named %>%
mutate(chemical = case_when(
str_detect(chemical, "Chromium  and Chromium Compounds") ~ "Chromium and Chromium Compounds",
str_detect(chemical, "Sulfuric acid") ~ "Sulfuric acid",
str_detect(chemical, "Nitrate compounds") ~ "Nitrate compounds",
str_detect(chemical, "Barium compounds") ~ "Barium compounds (except for barium sulfate)",
TRUE ~ chemical
))
# Now proceed with your summary and plotting code
chem_release_summary_haz <- toxins_named %>%
filter(clean_air_act_chemical == "YES") %>%
group_by(chemical) %>%
summarise(total_releases = sum(total_releases, na.rm = TRUE)) %>%
arrange(desc(total_releases)) %>%
head(10)
# Plot for Clean Air Act Chemical (Horizontal Bar Plot) - Top 10
p1 <- ggplot(chem_release_summary_haz, aes(x = reorder(chemical, total_releases), y = total_releases, fill = chemical)) +
geom_bar(stat = "identity", width = 0.7, show.legend = FALSE) +
coord_flip() +
labs(title = "Top 10 Toxins Released",
y = "Total Release",
x = "Chemical") +
theme_minimal() +
theme(axis.text.y = element_text(angle = 0, hjust = 1),
plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(labels = scales::comma)
# Now proceed with your summary and plotting code
chem_release_summary_non <- toxins_named %>%
filter(clean_air_act_chemical == "NO") %>%
group_by(chemical) %>%
summarise(total_releases = sum(total_releases, na.rm = TRUE)) %>%
arrange(desc(total_releases)) %>%
head(10)
# Plot for Clean Air Act Chemical (Horizontal Bar Plot) - Top 10
p2 <- ggplot(chem_release_summary_non, aes(x = reorder(chemical, total_releases), y = total_releases, fill = chemical)) +
geom_bar(stat = "identity", width = 0.7, show.legend = FALSE) +
coord_flip() +
labs(title = "Top 10 Toxins (Non Hazardous) Released",
y = "Total Release",
x = "Chemical") +
theme_minimal() +
theme(axis.text.y = element_text(angle = 0, hjust = 1),
plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(labels = scales::comma)
# Summarize release amounts by classification
classification_summary <- toxins_named %>%
group_by(classification) %>%
summarise(total_release = sum(total_releases, na.rm = TRUE)) %>%
arrange(desc(total_release))
# Plot for Classification (Top 10)
p3 <- classification_summary %>%
top_n(10, total_release) %>%
ggplot(aes(x = reorder(classification, total_release), y = total_release, fill = classification)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = "Top 10 Toxins Released by Classification",
y = "Total Release",
x = "Classification") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(labels = comma)
# Pivot data to gather different release methods
release_methods <- toxins_named %>%
select(chemical, fugitive_air, stack_air, water,
underground_cl_i, underground_c_ii_v,
`1a_rcra_c_landfill`, `1b_other_landfills`,
other_disposal) %>%
pivot_longer(cols = fugitive_air:other_disposal,
names_to = "release_method",
values_to = "amount") %>%
group_by(release_method) %>%
summarise(total_amount = sum(amount, na.rm = TRUE))
# Rename release methods for better readability
release_methods <- release_methods %>%
mutate(release_method = case_when(
release_method == "fugitive_air" ~ "Fugitive Air",
release_method == "stack_air" ~ "Stack Air",
release_method == "water" ~ "Water",
release_method == "underground_cl_i" ~ "Underground Class I",
release_method == "underground_c_ii_v" ~ "Underground Class II-V",
release_method == "1a_rcra_c_landfill" ~ "RCRA C Landfill",
release_method == "1b_other_landfills" ~ "Other Landfills",
release_method == "other_disposal" ~ "Other Disposal",
TRUE ~ release_method
))
# Plot for Different Release Methods
p4 <- ggplot(release_methods, aes(x = reorder(release_method, total_amount), y = total_amount, fill = release_method)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = "Amounts Released by Different Onsite Methods",
x = "Release Method",
y = "Total Amount") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(hjust = 0.5)) +
scale_y_continuous(labels = comma) +
scale_fill_brewer(palette = "Set3")
# List of offsite release methods (excluding total)
offsite_methods <- c("m10", "m41", "m62", "m81", "m82",
"m66", "m67", "m64", "m65", "m73", "m79",
"m90", "m94", "m99")
# Pivot data to gather different offsite release methods
offsite_release_methods <- toxins_named %>%
select(all_of(offsite_methods)) %>%
pivot_longer(cols = everything(),
names_to = "release_method",
values_to = "amount") %>%
group_by(release_method) %>%
summarise(total_amount = sum(amount, na.rm = TRUE))
# Rename release methods for better readability
offsite_release_methods <- offsite_release_methods %>%
mutate(release_method = case_when(
release_method == "m10" ~ "Storage Only",
release_method == "m41" ~ "Solidification/Stabilization",
release_method == "m62" ~ "Wastewater Treatment",
release_method == "m81" ~ "Landfill/Disposal Surface Impoundment",
release_method == "m82" ~ "Land Treatment",
release_method == "m66" ~ "Other Waste Treatment",
release_method == "m67" ~ "Other Waste Treatment",
release_method == "m64" ~ "Other Disposal",
release_method == "m65" ~ "Other Disposal",
release_method == "m73" ~ "Land Treatment",
release_method == "m79" ~ "Other Land Disposal",
release_method == "m90" ~ "Other Off-Site Management",
release_method == "m94" ~ "Transfer to Waste Broker",
release_method == "m99" ~ "Unknown",
TRUE ~ release_method
))
# Plot for Different Offsite Release Methods
p5 <- ggplot(offsite_release_methods, aes(x = reorder(release_method, total_amount), y = total_amount, fill = release_method)) +
geom_bar(stat = "identity") +
coord_flip() +
labs(title = "Amounts Released by Different Offsite Methods",
x = "Release Method",
y = "Total Amount") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(hjust = 0.5),
axis.text.y = element_text(size = 8)) +  # Smaller text for y-axis labels
scale_y_continuous(labels = comma) +
scale_fill_brewer(palette = "Set3")
# Calculate proportions for treated, recycled, etc.
proportions <- toxins_named %>%
summarise(
total_treated = sum(treatment_on_site + treatment_off_site, na.rm = TRUE),
total_recycled = sum(recycling_on_site + recycling_off_sit, na.rm = TRUE),
total_energy_recovery = sum(energy_recover_on + energy_recover_of, na.rm = TRUE),
total_release = sum(total_releases, na.rm = TRUE)
) %>%
pivot_longer(everything(), names_to = "category", values_to = "amount") %>%
mutate(proportion = amount / sum(amount),
category = case_when(
category == "total_treated" ~ "Treated",
category == "total_recycled" ~ "Recycled",
category == "total_energy_recovery" ~ "Energy Recovery",
category == "total_release" ~ "Released",
TRUE ~ category
))
# Plot for Proportions
p6 <- ggplot(proportions, aes(x = reorder(category, -proportion), y = proportion, fill = category)) +
geom_bar(stat = "identity") +
geom_text(aes(label = scales::percent(proportion, accuracy = 0.1)),
position = position_stack(vjust = 0.5)) +
labs(title = "Proportion of Toxins Treated, Recycled, Recovered, and Released",
x = "Category",
y = "Proportion") +
theme_minimal() +
theme(legend.position = "none") +
scale_y_continuous(labels = scales::percent) +
scale_fill_brewer(palette = "Set2")
# Calculate on-site and off-site releases
onsite_offsite_summary <- toxins_named %>%
summarise(
on_site_release = sum(on_site_release_total, na.rm = TRUE),
off_site_release = sum(off_site_release_total, na.rm = TRUE)
) %>%
pivot_longer(everything(), names_to = "release_type", values_to = "amount") %>%
mutate(release_type = case_when(
release_type == "on_site_release" ~ "On-Site Release",
release_type == "off_site_release" ~ "Off-Site Release",
TRUE ~ release_type
))
# Calculate percentages
total_release <- sum(onsite_offsite_summary$amount)
onsite_offsite_summary <- onsite_offsite_summary %>%
mutate(percentage = amount / total_release * 100)
# Plot for On-Site vs Off-Site Releases
p7 <- ggplot(onsite_offsite_summary, aes(x = release_type, y = amount, fill = release_type)) +
geom_bar(stat = "identity", width = 0.6) +
geom_text(aes(label = paste0(comma(amount), "\n(", round(percentage, 1), "%)")),
position = position_stack(vjust = 0.5),
size = 4) +
labs(title = "Comparison of On-Site vs Off-Site Releases",
x = NULL,  # Remove x-axis label as it's redundant
y = "Total Amount",
fill = "Release Type") +
theme_minimal() +
theme(legend.position = "none",  # Remove legend as it's redundant
axis.text.x = element_text(size = 12, face = "bold"),
plot.title = element_text(hjust = 0.5, size = 16, face = "bold")) +
scale_y_continuous(labels = comma) +
scale_fill_brewer(palette = "Set2")
ggplotly(p1)
library(dplyr)
library(readr)
library(DataExplorer)
library(cluster)
library(factoextra)
library(FactoMineR)
library(janitor)
library(ggplot2)
library(tidyr)
library(reshape2)
library(stringr)
library(scales)
library(ggplotly)
library(dplyr)
library(readr)
library(DataExplorer)
library(cluster)
library(factoextra)
library(FactoMineR)
library(janitor)
library(ggplot2)
library(tidyr)
library(reshape2)
library(stringr)
library(scales)
library(plotly)
knitr::opts_chunk$set(echo = TRUE)
ggplotly(p1)
ggplotly(p2)
ggplotly(p3)
ggplotly(p4)
ggplotly(p5)
ggplotly(p6)
ggplotly(p7)
# Step 1: Load necessary libraries
library(FactoMineR)
library(factoextra)
# Step 2: Prepare the data
mfa_toxins <- toxins_2023
# Step 3: Select variables for MFA (replace indices with appropriate column numbers)
MFAData <- toxins_2023[, c(37, 23, 46, 8, 44, 65, 88, 94, 106, 107, 119)]
# Step 4: Convert categorical variables to factors and numerical to numeric
# Adjust column indices based on the dataset
categorical_cols <- c(1, 2, 3, 4, 5)  # Example indices for categorical variables
numerical_cols <- c(6, 7, 8, 9, 10, 11)  # Example indices for numerical variables
MFAData[categorical_cols] <- lapply(MFAData[categorical_cols], as.factor)
MFAData[numerical_cols] <- lapply(MFAData[numerical_cols], as.numeric)
# Step 5: Remove rows with missing values
MFAData <- na.omit(MFAData)
# Step 6: Random sampling if dataset is too large
sample_size <- 1000  # Define the desired sample size
if (nrow(MFAData) > sample_size) {
set.seed(123)  # Ensure reproducibility
MFAData <- MFAData[sample(1:nrow(MFAData), sample_size), ]
}
# Step 7: Define groups and types for each variable
group_sizes <- rep(1, ncol(MFAData))  # Each variable is its own group
types <- c(rep("n", length(categorical_cols)), rep("s", length(numerical_cols)))  # Types for each variable
# Step 8: Run MFA
MFA1 <- MFA(
MFAData,
group = group_sizes,  # Each variable treated as a separate group
type = types,         # Specify type for each variable
name.group = colnames(MFAData),  # Use column names for group names
graph = FALSE         # Do not automatically plot graphs
)
# Step 9: Visualizations
# Scree plot: variance explained by dimensions
fviz_screeplot(MFA1, addlabels = TRUE, ylim = c(0, 50))
# Variable contributions to the dimensions
fviz_mfa_var(MFA1,
repel = TRUE,  # Avoid label overlap
col.var = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Individuals (data points) representation
fviz_mfa_ind(MFA1,
repel = TRUE,  # Avoid label overlap
geom = "point",
col.ind = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Variable contributions to the dimensions (by group)
fviz_mfa_var(mfa_result, "group",
repel = TRUE,  # Avoid label overlap
col.var = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Step 1: Load necessary libraries
library(FactoMineR)
library(factoextra)
# Step 2: Prepare the data
mfa_toxins <- toxins_2023
# Step 3: Select variables for MFA (replace indices with appropriate column numbers)
MFAData <- toxins_2023[, c(37, 23, 46, 8, 44, 65, 88, 94, 106, 107, 119)]
# Step 4: Convert categorical variables to factors and numerical to numeric
# Adjust column indices based on the dataset
categorical_cols <- c(1, 2, 3, 4, 5)  # Example indices for categorical variables
numerical_cols <- c(6, 7, 8, 9, 10, 11)  # Example indices for numerical variables
MFAData[categorical_cols] <- lapply(MFAData[categorical_cols], as.factor)
MFAData[numerical_cols] <- lapply(MFAData[numerical_cols], as.numeric)
# Step 5: Remove rows with missing values
MFAData <- na.omit(MFAData)
# Step 6: Random sampling if dataset is too large
sample_size <- 1000  # Define the desired sample size
if (nrow(MFAData) > sample_size) {
set.seed(123)  # Ensure reproducibility
MFAData <- MFAData[sample(1:nrow(MFAData), sample_size), ]
}
# Step 7: Define groups and types for each variable
group_sizes <- rep(1, ncol(MFAData))  # Each variable is its own group
types <- c(rep("n", length(categorical_cols)), rep("s", length(numerical_cols)))  # Types for each variable
# Step 8: Run MFA
MFA1 <- MFA(
MFAData,
group = group_sizes,  # Each variable treated as a separate group
type = types,         # Specify type for each variable
name.group = colnames(MFAData),  # Use column names for group names
graph = FALSE         # Do not automatically plot graphs
)
# Step 9: Visualizations
# Scree plot: variance explained by dimensions
fviz_screeplot(MFA1, addlabels = TRUE, ylim = c(0, 50))
# Variable contributions to the dimensions
fviz_mfa_var(MFA1,
repel = TRUE,  # Avoid label overlap
col.var = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Individuals (data points) representation
fviz_mfa_ind(MFA1,
repel = TRUE,  # Avoid label overlap
geom = "point",
col.ind = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Variable contributions to the dimensions (by group)
fviz_mfa_var(MFA1, "group",
repel = TRUE,  # Avoid label overlap
col.var = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Quantitative variables
fviz_mfa_var(MFA1,
choice = "quanti.var",  # For quantitative variables
repel = TRUE,           # Avoid label overlap
col.var = "cos2",       # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Categorical variables
fviz_mfa_var(MFA1,
choice = "quali.var",  # For categorical variables
repel = TRUE,
col.var = "cos2",
gradient.cols = c("blue", "green", "red"))
# Categorical variables (dimensions 1 and 2)
fviz_mfa_var(MFA1,
choice = "quali.var",       # Focus on categorical variables
repel = TRUE,              # Avoid label overlap
col.var = "cos2",          # Color by quality of representation
gradient.cols = c("blue", "green", "red"),
axes = c(1, 2))            # Specify dimensions to plot
# Step 1: Load necessary libraries
library(FactoMineR)
library(factoextra)
# Step 2: Prepare the data
mfa_toxins <- toxins_2023
# Step 3: Select variables for MFA (replace indices with appropriate column numbers)
MFAData <- toxins_2023[, c(37, 23, 46, 8, 44, 65, 88, 94, 106, 107, 119)]
# Step 4: Convert categorical variables to factors and numerical to numeric
# Adjust column indices based on the dataset
categorical_cols <- c(1, 2, 3, 4, 5)  # Example indices for categorical variables
numerical_cols <- c(6, 7, 8, 9, 10, 11)  # Example indices for numerical variables
MFAData[categorical_cols] <- lapply(MFAData[categorical_cols], as.factor)
MFAData[numerical_cols] <- lapply(MFAData[numerical_cols], as.numeric)
# Step 5: Remove rows with missing values
MFAData <- na.omit(MFAData)
# Step 6: Random sampling if dataset is too large
sample_size <- 1000  # Define the desired sample size
if (nrow(MFAData) > sample_size) {
set.seed(123)  # Ensure reproducibility
MFAData <- MFAData[sample(1:nrow(MFAData), sample_size), ]
}
# Step 7: Define groups and types for each variable
group_sizes <- rep(1, ncol(MFAData))  # Each variable is its own group
types <- c(rep("n", length(categorical_cols)), rep("s", length(numerical_cols)))  # Types for each variable
# Step 8: Run MFA
MFA1 <- MFA(
MFAData,
group = group_sizes,  # Each variable treated as a separate group
type = types,         # Specify type for each variable
name.group = colnames(MFAData),  # Use column names for group names
graph = FALSE         # Do not automatically plot graphs
)
# Step 9: Visualizations
# Scree plot: variance explained by dimensions
fviz_screeplot(MFA1, addlabels = TRUE, ylim = c(0, 50))
# Variable contributions to the dimensions
fviz_mfa_var(MFA1,
repel = TRUE,  # Avoid label overlap
col.var = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Individuals (data points) representation
fviz_mfa_ind(MFA1,
repel = TRUE,  # Avoid label overlap
geom = "point",
col.ind = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Variable contributions to the dimensions (by group)
fviz_mfa_var(MFA1, "group",
repel = TRUE,  # Avoid label overlap
col.var = "cos2",  # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
# Quantitative variables
fviz_mfa_var(MFA1,
choice = "quanti.var",  # For quantitative variables
repel = TRUE,           # Avoid label overlap
col.var = "cos2",       # Color by quality of representation (cos2 indicates the quality)
gradient.cols = c("blue", "green", "red"))
